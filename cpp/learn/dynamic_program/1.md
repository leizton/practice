# 动态规划设计模式
https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns

# items
5
42
44
53
62
64
72
87
97
115
119     杨辉三角
121     买卖股票的最佳时机
122     买卖股票的最佳时机-II
131     分割回文子串
139     单词拆分
140     单词拆分, 在139基础上返回所有可能结果

# 《序列的子串分割》
131  140
~~~c++
vector<vector<int>> gh(n);
if (is_ok(0, 0))
  gh[0].push_back(-1);
for (int i = 1; i < n; i++) {
  if (is_ok(0, i)) {
    gh[i].push_back(-1);
  }
  for (int j = 1; j <= i; j++) {
    if (!gh[j-1].empty() && is_ok(j, i))
      gh[i].push_back(j-1);
  }
}
~~~

# 字符串
## 给定两个字符串 s, t
72  44  5  115
~~~c++
// 从1开始是因为0表示空串
for (int i = 1; i <= m; i++)
  for (int j = 1; j <= n; j++)
    if s[i-1] == t[j-1]
      dp[i][j] = ...;
    else
      dp[i][j] = ...;
~~~
## 给定一个字符串 s
~~~c++
for (int i = 1; i < n; i++)
  for (int j = i; j < n; j++)
    if s[i] == s[j]
      dp[i][j] = ...;
    else
      dp[i][j] = ...;
~~~

# Minimum (Maximum) Path to Reach a Target
递归式：f(i) = min{f(i-1), f(i-2), ...}

# Distinct Ways
递归式：f(i) = f(i-1) + f(i-2) + ...

# Merging Intervals
递归式： dp[i][j] = dp[i][k] + result[k] + dp[k+1][j]

# 数组连续区间
以i作起点或终点
42  53

# m × n 方格的路径
62  64

# memo大法
memo的key是参数, value是答案
树搜索过程中, 自顶向下: 87 97
139

# 树图类搜索思想的动规
1. memo大法

# 如何选取状态
122  131

# 回溯法: 基于分治思想的深度遍历
131  139