# 动态规划设计模式
https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns


# items
5
42
44
53
62      m×n网格上的不同路径数
63      62附加，网格中有障碍物
64      m×n网格的最小路径和
72
87
97
115
119     杨辉三角
121     买卖股票的最佳时机
122     买卖股票的最佳时机-II
131     分割回文子串
139     单词拆分
140     139附加，返回所有可能结果
152     乘积最大子数组
174     地下城游戏
241     运算表达式的所有可能优先级
300     最长严格递增子序列


# 《序列的子串分割》
131  140
~~~c++
vector<vector<int>> gh(n);
if (is_ok(0, 0))
  gh[0].push_back(-1);
for (int i = 1; i < n; i++) {
  if (is_ok(0, i)) {
    gh[i].push_back(-1);
  }
  for (int j = 1; j <= i; j++) {
    if (!gh[j-1].empty() && is_ok(j, i))
      gh[i].push_back(j-1);
  }
}
~~~


# 《子串最优值》
dp[i]是以i结尾的子串的最优值
dp[i] = max{ dp[i-1]+s[i], s[i] }  // +表示广义的加.乘.组合
时间复杂度O(n)
152


# 《子序列最优值》
dp[i]是以i结尾的子序列的最优值
dp[i] = max{ dp[0]+s[i], dp[1]+s[i], ..., dp[i-1]+s[i], s[i] }
时间复杂度O(n²)
300


# 《子串的二维dp》
子串s[l:r]上的结果由多个 s[l:split]+s[split+1:r] 组合得到
从对角线往右上角推导
241  dp[l:r] = { dp[l:l]+dp[l+2,r], dp[l:l+2]+dp[l+4][r], ..., dp[l:r-2]+dp[r:r] }


# 《m×n网格的路径》
每次只能往右或往下移动, dp[i][j] 由 dp[i-1][j] dp[i][j-1] 推导出来
从(0,0)正向推到(m-1,n-1)  62  64
从(m-1,n-1)反向推到(0,0)  174


# 字符串
## 给定两个字符串 s, t
72  44  5  115
~~~c++
// 从1开始是因为0表示空串
for (int i = 1; i <= m; i++)
  for (int j = 1; j <= n; j++)
    if s[i-1] == t[j-1]
      dp[i][j] = ...;
    else
      dp[i][j] = ...;
~~~
## 给定一个字符串 s
~~~c++
for (int i = 1; i < n; i++)
  for (int j = i; j < n; j++)
    if s[i] == s[j]
      dp[i][j] = ...;
    else
      dp[i][j] = ...;
~~~


# Minimum (Maximum) Path to Reach a Target
递归式：f(i) = min{f(i-1), f(i-2), ...}


# Distinct Ways
递归式：f(i) = f(i-1) + f(i-2) + ...


# Merging Intervals
递归式： dp[i][j] = dp[i][k] + result[k] + dp[k+1][j]


# 数组连续区间
以i作起点或终点
42  53


# memo大法
memo的key是参数, value是答案
树搜索过程中, 自顶向下: 87 97
139


# 树图类搜索思想的动规
1. memo大法


# 如何选取状态
122  131


# 回溯法: 基于分治思想的深度遍历
131  139