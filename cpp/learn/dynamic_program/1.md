# 动态规划设计模式
https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns


# items
5
42
44
53
62      m×n网格上的不同路径数
64      m×n网格的最小路径和
72
87
97
115
119     杨辉三角
121     买卖股票的最佳时机
122     买卖股票的最佳时机-II
131     分割回文子串
139     单词拆分
140     单词拆分, 在139基础上返回所有可能结果
152     乘积最大子数组
174     地下城游戏


# 《序列的子串分割》
131  140
~~~c++
vector<vector<int>> gh(n);
if (is_ok(0, 0))
  gh[0].push_back(-1);
for (int i = 1; i < n; i++) {
  if (is_ok(0, i)) {
    gh[i].push_back(-1);
  }
  for (int j = 1; j <= i; j++) {
    if (!gh[j-1].empty() && is_ok(j, i))
      gh[i].push_back(j-1);
  }
}
~~~


# 《子串最优值》
dp[i]是以i结尾的子串的最优值, dp[i] 由 dp[i-1] s[i] 推导出来
152


# 《m×n网格的路径》
每次只能往右或往下移动, dp[i][j] 由 dp[i-1][j] dp[i][j-1] 推导出来
从(0,0)正向推到(m-1,n-1)  62  64
从(m-1,n-1)反向推到(0,0)  174


# 字符串
## 给定两个字符串 s, t
72  44  5  115
~~~c++
// 从1开始是因为0表示空串
for (int i = 1; i <= m; i++)
  for (int j = 1; j <= n; j++)
    if s[i-1] == t[j-1]
      dp[i][j] = ...;
    else
      dp[i][j] = ...;
~~~
## 给定一个字符串 s
~~~c++
for (int i = 1; i < n; i++)
  for (int j = i; j < n; j++)
    if s[i] == s[j]
      dp[i][j] = ...;
    else
      dp[i][j] = ...;
~~~


# Minimum (Maximum) Path to Reach a Target
递归式：f(i) = min{f(i-1), f(i-2), ...}


# Distinct Ways
递归式：f(i) = f(i-1) + f(i-2) + ...


# Merging Intervals
递归式： dp[i][j] = dp[i][k] + result[k] + dp[k+1][j]


# 数组连续区间
以i作起点或终点
42  53


# memo大法
memo的key是参数, value是答案
树搜索过程中, 自顶向下: 87 97
139


# 树图类搜索思想的动规
1. memo大法


# 如何选取状态
122  131


# 回溯法: 基于分治思想的深度遍历
131  139