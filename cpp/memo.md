图形化思考和记忆
阅读代码时关注`数据流`，核心流转数据的修改即是核心流程
  先理解整体流程，把最上层流程的每个步骤用自然语言描述，每个概念取一个好的名字
  再深入各步骤的细节
  迭代机: read --> simplify-code(replace by annocation)
           ↑  <--    ↓
代数和几何在本质上的相同
观察问题的方法论
  最优化思想
  分层思想
    视频、文本 --> 图像、句子 -分割-> 目标、短语(phrase)
解决问题的方法论
  分解、分治
如何达成目标
  任何事件只要坚持做下去就一定能取得突破性成果
跳跃地看书，原因是章节顺序和我们的思维顺序不一致，让思维连续可以提高效率
代码设计中的原子分子思想：原子--不可拆分的逻辑，分子--由原子线性或关联式组合
需求来源有两种 ① 改进现有 ② 新增功能
思想理论得以实现的基础是可计算
做笔记的时候进行深度和广度思考
  哲学家的深度思考指探索更本质的模型、理念、理论、概念
  梦想家的广度联想和想象指关联已有知识，做现实场景例子的思想实验，发散式思考如新应用等
看书和看代码都要跳出细节纵观全局
重构或重做的意义和价值在于解决之前做的现在不适合的设计、理念，以及一些半成品
很多paper是在前人突破性进展上提升一两个百分点，这些paper最终会被未来某次突破性进展所淘汰
归纳总结 -> 第一性原理、底层逻辑 -> 推理演绎 -> 形成理论 -> 实践修正
把tensorflow、深度模型看出一种编程语言
人工智能目前有传统统计学、机器学习、深度学习这些技术，但缺乏理论
在w2v中，emb主要是建模了entry之间的相关关系(空间距离)，但feature还应包括entry自身的元信息、entry间多种类型的关系
引擎/组件应抽象包含业务逻辑，不能只是提供空接口
  带抽象逻辑的引擎/组件可以帮助业务团队快速完成需求，业务团队感受到便利和清晰的逻辑后就会按照引擎的规则(软件约束)来开发
  引擎和框架不同，框架或说基础架构仅是工具，引擎对应某方面业务，是架构设计的软件实现
`架构工作的本质是设计合理的约束`，相当于设置假设条件
  业务方基于架构开发就是基于假设条件进行推导，得出结论、定理
  因此架构的工作本应先于业务，但现实中人们往往不能在业务做到一定程度前就对业务有一定的认知，另外认知会变化，所以架构会迭代和重构
  当业务起步后，架构的工作基本上就是先于业务，架构人员已经具备了业务预判能力(因为知道所有可能的推导路径)
  不过现实中具有预判能力的人很少，这当然是因为大多数人是平庸的
  具备预判能力的方法是多归纳和学会抽象，以历史预测未来
  引擎就是把约束推进到更具体细分的业务
架构花给业务方做收益不明确的探索任务
为什么阅读代码、接触新事物时会出现困难、迷茫占主导情绪，而不是好奇、新鲜感占主导情绪
  我们在面对未知事物时总想第一时间抓住全部信息，但这是超出任何人的能力区间的
  第一次接触时应抓少量的关键信息，从objective入手推演出有哪几个方面，掌握第一性原理和底层逻辑
  整个过程中应让自己尽可能掌握最少的信息，其余信息(知识)都是推演出的，这就是所谓的理解过程
onTimeout() 通知
解题过程
  1. 大胆猜测 从先验直觉灵感猜测一个答案 (意义在于)这个答案给出了一个继续前进的方向
  2. 小心求证 通过实例辅助 或反证法 用严密的逻辑推理证明答案的正确性
  3. 如果答案不对 或求证过程中发现新思路新可能 回退到第1步
幸福第一，成就第二
  关于物质生活和世俗生活，应该追求幸福而不是物质享受，应该追求精神思想的升华而不是世俗权利的拥有
模块和组件的2个特点: 在场景中有效; 可持续性发挥效果;
  例如 算法: 可以提升指标; 可迭代维持指标不降甚至提升
假设来自直觉
以朴素的思想解决核心问题。朴素, 符合客观，务实有效，实则简单。因此不应往观点上带入过多的主观猜测
开放、自由、民主(和而不同)、活力
分享前收集大家感兴趣的问题，即互联网用户思维
如果想做好分享，应该先多看看别人的分享，从中学习优缺点，也就是说第一步是模仿和学习
tf中用短作用域变量代替长作用域的ctx并不合适，传递变量需要加锁对性能影响大
相似!=相关; 相关!=因果; 相异!=矛盾, 例如微观物质运动上具有波粒二象性, 可以同时正确
把分享变成讲故事，故事有过程就会生动，符合直觉的地方语言要清晰明了、简短
  客观事实和直觉不一致的地方要给出关于客观事实的全面信息，再说明不一致的点
几种思维模式：模型思维(简化无关细节)，系统思维(元素和关系)
记忆例子和具体场景比记忆文字抽象描述的概念更深刻, 因为可以代入意识的编织和想象
monitor: time(avg p50 p99), qps, fail_ratio(timeout+error), gauge
技术选型(方案、工具、实现原理)的重要性比技术实现更高，80%的精力用在调研和选型，20%的精力用在实现
  技术选型的关键在于balance，确定各项指标的权重
  例如对于一个rpc框架，重要的已经不是性能了，因为各种实现的性能diff在10%以内
  重要的是稳定性/无bug/易用性，这样可以极大地减少使用者的时间成本
每个人的成长后面都有众多人的付出，回报付出的最好方式是帮助更多的人
代码性能优化的两个思路：1 去除重复的冗余计算；2 使用新的算法(计算方法)；3 有损处理
信息流短视频如此的0.7并非reco而是小米，类比因特尔如此的0.7的鸡蛋不是网根
我们对世界的认知永远是部分的、非系统的，所以不要害怕认知错误，而因坦然接受
经济活动参与者都是理性选择，即最大化自身利益，区别在于对信息全面性的掌握程度
  有两种参与者，组织和群体，后者符合热力学统计原理，前者有明显的选择倾向
    前者会集中力量到所选方向上，所以前者对未来影响大
    前者会主动干预后者，但不一定能成功，因为后者占据70%的趋势力量，所以前者的选择未必符合所想
    前者有对未来的影响力，后者有对未来的决定力，如同tGan和dZhi，前者显性后者隐性
  对于信息要有选择，要选出宏观信息以及刺激前者神经的信息
人通过所见所想而对世界形成的认知是非常有限的，就像走迷宫一条看似可以走很远的路最终并不通向出口。
软件设计中，设计模式、设计原则并非实际难点，实际难点是准确判断业务的变化点。判断出变化点后留出可扩展接口是容易的
用类多态代替函数指针
方案应该是逻辑通畅，清晰明了，没有冗余
架构和引擎不同，引擎只面向内部的单个软件服务，架构是面向用户的业务性服务
对于团队来说团结永远是第一位，就像有苏联时美国能团结从而强大，不团结后就进入衰退
天赋具体表现起来就是非逐级地打怪，而是调级打怪
一个重要的能力是处理大量信息的能力
一项重要的架构工作：挖掘(抽象)业务的编程范式。挖掘复杂业务逻辑背后的范式，例如推荐业务的两阶段范式。
  模块层面，范式就是设计模式。范式本质上是业务的软件(代码)工程实现模型，作用是简化对业务的认知
架构能力: 抽象 分治(分层) 复用 迭代
需要多方合作的项目一定要有项目文档，介绍背景和来龙去脉、预期收益、计划安排、相关合作方
  与合作方沟通时要明确希望对方提供怎样的帮助，预期有怎样的收益给到合作方，调动起来合作方的积极性
把学过的了解了思想，能在互联网搜索引擎的帮助下独立实现的东西反复再学一遍并没有什么意义
读论文时直接找到和关注核心思想和核心方法，忽略各种细节
不成体系的信息输出，是经验、语录、微博，不是知识，即使在某些场景下是正确的也因为不清楚为什么正确，从而无法基于这些信息去推导发展更多的信息
思考并收集数据(证据)，不断询问找到问题的根本原因
除了系统框架级的结构化信息，还保持掌握关键细节数据信息的优势
好的设计和实现被修改的少，扩展维度的多

非预期现象 -> 待解决的本质问题(出现该现象的根本原因) -> 解决思想和思路 -> 具体的解决方案和方法
  观察现象感知到的问题 -> 问题本质是什么，问题出现的本质原因是什么
概念/名词 -> 定义问题
以思想/猜想/假设作为起点 经过严密的逻辑推导 得出解决问题的结论

语言处理的句子结构, 词之间的关系
无监督聚类, 概念空间
点云、运动轨迹平滑

@ref
弄懂知识的底层逻辑才是举一返三、融会贯通的高手
思考一个问题，首先是找到一个入口，屡出一条线(即思考路径)，这是思考的基本原则
  入口会很多，每个入口开启不同的路径，所选择的路径最终是否在围绕问题本质需要考察
netflix: focus on problems, not ideas. 一个idea是一次尝试，大概率会失败被遗忘，但problem永远不会消失
一个优秀的程序员在接到“毁灭地球”的需求时，写出的代码不是destoryEarth()而是destoryPlanet()，并将earth作为一个参数传进去
  大家更关注代码扩展性和思维上的抽象能力

工作中需关注重点、难点、亮点
重点：需求痛点, 核心功能, 系统性的问题
难点: 功能实现中遇到的很难解的问题
亮点：创新点、新思路、巧妙的方案方法, 解决了难点问题

可计算问题 图灵机 图灵完备
https://www.zhihu.com/question/20115374

BitFunnel
https://www.jiqizhixin.com/articles/2019-11-20-15

4种容器网络模式
https://blog.csdn.net/qq_38622229/article/details/81840516

日志收集和分析
1. 收集包含指定 keyword 的日志行, 同时过滤掉无需收集的日志
2. agent 做初步解析, 解析结果包括 {app, ip, timestamp, row_id, kv_list}
    row_id 是日志行的唯一标识, 类型是`uint64_t`, 默认用 snowflake 生成
    kv_list 是一个 kv pair 的数组, key value 的类型都是string
3. 通过消息队列发送出去, 如 kafka
4. 用实时流计算框架做OLAP, 如 flink-sql

编程模型
  - 偏于关注数据抽象
    面向对象
  - 偏于关注数据处理
    接口命令式: 面向接口编程
    数据流声明式: java8 stream; 针对某一种数据类型的迭代操作, 数据类型 List<T>
      [flink 数据流编程模型](./adoc/flink/Dataflow_Programming_Model.pdf)
      批数据声明式: 接口参数是list型
    响应式函数编程: 数据流声明式的异步化; 事件(数据)驱动式
数据模型
  - 传统结构体: protobuf
  - 列式内存数据: arrow; 无schema批量数据

分析X业务则必须了解X业务的各类数据和各类逻辑, 数据和业务逻辑无关有形的架构、代码.

业务引擎的图化
- 算子构图的本质和意义
  一种新的并发友好、依赖清晰的编程语言
- why
  每个业务都有稳定的核心的领域模型
  业务领域模型由三者组成：业务数据对象、数据对象的内部处理、数据对象之间的动静关系
    动态关系：交互，依赖调用。静态关系：合成，包括组合(一对一)、聚合(一对多)、继承
  数据对象及其内部处理逻辑有面向对象编程建模
  当数据对象间的动静关系并没有设计思想指导时，开发出的代码常常是混乱的
    动态的混乱：复杂的多对多调用关系，很长的调用链
    静态的混乱：模块、类的职责边界模糊，某些类耦合太多数据及处理
- what
  图化核心的是改造成数据流图，思想和tensorflow数据流相同
  面向对象描述数据的合成关系，数据流图从代码和运行后的可视化图两方面更好地描述数据的交互关系
  数据流图第一表现的是数据处理依赖流程，借此可以实现最大可能的并发，同时根据节点上数据的读写通过代码静态分析找出并行安全问题
- how
  算子封装数据对象的内部原子处理，流图描述数据对象之间的动态关系
    应避免把图化只看成任务调度，任务调度只是调业务封装好的接口，这样的引擎没有和业务结合
    算子把业务里常见的通用的数据处理变成可复用的模块
    子图把更大尺度的业务逻辑变成可复用的模块
  算子之间传递的是数据对象实例
    不能混淆算子自身参数和输入输出，避免通过输入输出来设置算子参数
  数据对象的底层结构是列式存储，从而适应不同schema的具体业务
- more
  1. 数据对象之间的静态关系目前没有方案，一种想法是采用图存储思想
  2. 面向对象和数据流图本质上是软件设计和开发时用到的工具，需要开发者有意识地使用工具才能实现项目代码清晰
     譬如我们需要画一个正方形，不用任何工具也可以完成，但用直尺可以画得更像，如果用带刻度的直尺则可以很标准

推荐系统
- 宏观数据
  - 用户
    - 用户画像
    - 用户行为历史，不同业务字段相同
  - 正排 doc
    - 全量更新，增量更新
    - 实时更新的字段
  - 倒排 chain
    - 基于内容：频道 分类(cate) 标签(tag) 地域 人工运营
    - 基于协同过滤：u2i i2i u2u2i
    - 基于双塔向量：dssm
- 核心逻辑
  - 召回
  - 排序

推荐系统架构
  推荐前台
    业务逻辑单元: Recaller Filter Ranker
    前台引擎功能: 通用推荐流程抽象, 图化recall filter rank的执行; 访问各中台、平台的组件
    前台通用数据: UserInfo Item&ItemList Request/Response/Context Config
  推荐(数据)中台
    用户数据中台  正排和过滤中台   特征中台(用户和样本的在离线特征提取)
    召回服务(内容、i2i、向量召回)  模型服务(深度模型训练和排序算分)
  基础平台
    分布式缓存  分布式持久存储  分布式消息队列  分布式一致性kv数据库
    分布式计算  分布式数据库  OLAP/OLTP  时序数据库
    SRE相关: 分布式服务治理和追踪 监控报警 发布变更系统
    (平台指具有跨业务场景提供通用能力, 其数据模型具有业务无关性)

推荐系统中定制ItemInfoList的目的是trace整个数据处理流程，不受限于系统是怎样的框架
需要专门设计 ItemInfo ItemInfoList UserProfile UserAction UserActionHistory 这些类，符合DDD

用户兴趣特征经过了3个阶段，或者说3种形态
  阶段1：单标签(cate/tag)的ctr权重向量，再加上时间衰减
  阶段2：用组合标签(交叉特征)做LR、FM模型预估ctr
  阶段3：深度模型学出embedding向量
趋势上看形态变复杂，embedding是极限很难继续
当前系统这3个形态都存在
  形态2变成深度模型，作用是排序
  形态1和形态3作用是召回，形态3还有一个作用是粗排
  形态1比形态3更能召回冷门和长尾item，这是形态1还存在于在线部分的原因
对于当前状况感觉有两点可以改进
  首先形态2和形态3的原始输入特征一部分来自形态1，所以优先看形态1
  形态1本质上是在展点上对item属性(最原始的特征)做计算，得出属性和用户的匹配值
  所以优化点有两个
    1. 扩大参与计算的展点量，即现在的超长序列
    2. 优化计算方法
  FeatureVector是ctr权重向量，对于多目标把时长加进去(可能现在已经有了)
  如何算权重可以不止是一个简单的点击除展现
  时间衰减参数随不同特征、不同类型用户可以调优
  标签体系经过了这么多年没有加入新类型标签，看来标签类型已经饱和了
总结
  用户兴趣特征有3种类型：单标签(cate/tag/topic等)，组合标签(交叉特征)，embedding向量
  embedding是机器表达能力的极限，mind又从单向量变多向量，所以很难更复杂了。高维路线无法继续，所以需要换一个角度
  由于后面两种类型的原始输入特征一部分是类型1，所以先看类型1
  类型1的本质是在展点上对item属性(最原始特征)做计算，得出属性和用户匹配值
  那么就有两个优化角度：输入(item属性/标签)和计算方法
    对于输入，标签体系已经过人工建立多年，并没有新标签不断产生，感觉已经饱和；现在扩序列即增加输入量是一个好的想法
    对于计算方法，FeatureVector是ctr权重向量，多目标把时长加进去(可能现在已经有了)，算权重可以不止是一个简单的点击除展现
      时间衰减参数随不同特征、不同类型用户可以调优
      或许原始的长序列输到模型本质上属于优化计算方法

企业软件系统的技术架构和组织架构
  技术架构
    [网关] [业务前台] [业务数据中台] [基础平台]
    微服务架构包裹网关、前台、中台, SpringCloud可以看成是微服务的代名词
  组织架构
    每个基础平台和业务中台由5或7人的团队负责研发, 这些系统按照云服务产品的要求来设计和实现
    SRE团队运维企业的微服务、监控、变更、资源管理等系统, 负责前台的高可用、高性能、可扩展
    业务研发团队更多的是和产运团队对接, 较少与SRE沟通
    子团队人数应是 2/5/7 三种, 5和7对应出一个leader其余人两两结对
    用软件工程的思想来设计团队, 那么子团队应是高内聚低耦合, 从而使沟通成本最低
    在人力系统中, 沟通是成本最高的类型, 团队间通过接口人沟通
    leader就是接口人, 负责把外部需求准确传递到内部, 使成员明白团队和自身的意义和价值
  架构设计
    技术和组织架构的设计不只是明白系统有哪些要素, 最重要的是设计和维护好要素间的关系, 这需要系统思维
    架构设计工作的最终目的是形成高可靠快速迭代的多业务系统

特征工程的重要性
  往业务里应用深度模型的时间一部分花在特征数据准备上
  好的特征可以在不同业务间互相借鉴

一种特征平台的运行时数据模型的逻辑视图
  一张宽表存放一次请求的所有数据
  表的行数是固定的, 等于输入的item_id数
  表的列分group, 每个group对应一个节点, 例如 source列族 对应请求原始参数 包含列有[item_id, user_profile]
  一个节点也可以创建出多个列族, 节点内通过 group.column 取得具体的列数据
  配置构图: 仅需配置节点的 inputs 和 outputs, 框架自动推导节点依赖关系变成图运行, 所以表的列数在运行前也是确定的
  对于list数据, 如果设置multi-record模式, 则表示这个list是多行; 否则是一行

深度模型
  单目标: ctr
  多目标: 图文点击/视频有效播放(播放时间超过5s相当于点击)、消费时长、、视频完播率
  粗排模型对视频点击有大的指标提升
  粗排模型: 双塔模型 user_embedding向量召回

AI算法发展
  专家系统: 手动配置规则; 规则式逻辑
  机器学习: 面向大量样本的数学最大化
  深度学习: 面向大量样本和大参数集的数学最大化, 和机器学习比能学到更多的人类认知规则
           本质是获得一个超函数, 超指无法写成表达式、参数巨多
           传统的统计学是选择一个合适的模型(函数类型), 然后用样本学习出函数的参数
           模型是对外在事物相互作用的数学上的抽象描述
           更多的时候, 复杂的相互作用不能用简单的函数表达, 因此传统机器学习效果不佳
           当前深度学习最大的问题是需要大量训练样本才能满足大量网络参数, 其次的问题是无法解释导致无法衡量可靠性
  机器学习是面向分类超平面，深度学习不一定是

uri (identifier) {
  url (locator) https://google.com
  urn (name) isbn:0-486-27557
}

重构的原则
1. 忠于原代码. 尽量不要根据自己的理解去优化代码
2. 逐步实施.
3. 简洁逻辑而非减少代码. 代码量可能会增加, 但目标是逻辑更清晰, 增加功能更容易
4. 选型上合适才是最好的.
@ref https://juejin.cn/post/6844903838193975304

什么时候必须得重构了
  现有的 数据模型(数据结构) 或 实现模型(业务逻辑处理流程) 对新功能新需求很不友好

架构设计的一些思考
过度设计的架构会让业务开发冗余代码，违背易用性的简洁原则
@ref https://juejin.cn/post/6844903639195074574

全链路日志
span的作用: 形成多层树状结构
https://juejin.cn/post/6965178897629462564

设计模式
设计模式本质是围绕类的`继承派生 组合聚合 依赖调用`来做的, 因为类与类之间的关系只有这三种
  派生: 自己作为项目组接口人, 和其他项目组(软件里的模块)交互, 把具体工作(具体实现)派发给后面的同事完成
  继承: 从接口人那里认领需求, 完成具体实现
  组合的形式只有两种: 链式(含集合) 和 映射式, 这也是容器种类、数据结构种类
举例
  行为型
    责任链模式   链式组合+依赖调用+派生
    命令模式     依赖调用+派生; 命令类依赖实现类
    访问者模式   依赖调用+派生; 访问者依赖数据元素
    迭代器模式   聚合+依赖调用; 容器类聚合数据元素, 迭代器依赖数据元素
    观察者模式   依赖调用+派生; Subject类(被观察者)状态变化时调用Observer(观察者)的接口;
                实际中通过异步消息队列、事件总线组件来解耦这个依赖
  结构型
    (以下省略依赖调用)
    代理模式     组合; 代理类组合一个实现类; client依赖代理类; 代理类起到保护实现类的作用
    装饰器模式   组合+派生; 装饰器组合一个实现类; 装饰器派生出子类扩展原实现的功能; client依赖装饰器
                装饰器和代理的区别在于多了一个派生, 使得他们的功能不同
    外观模式     集合式组合; 外观类组合多个不同实现类, 对外提供不同接口对应不同实现; client依赖外观类
    中介者模式   依赖调用; 类之间不直接交互, 而是通过中介者, 从而将网状依赖关系简化成星形
    桥接模式     依赖调用; client依赖原接口, 原接口依赖桥接接口;
                原本是桥接接口继承原接口, 自己再扩展新接口, 让具体类实现;
                因此会出现多层继承, 为了简化把桥接继承原接口的关系变成依赖关系
  创建型
    依赖构造方法
    抽象工厂就是在工厂模式上增加了派生
    对象的创建和管理最佳实践是用Spring的IoC思想(控制反转-依赖注入)
    控制指管理对象的生命周期, 甚至包括创建对象;
    反转指client不自己new实现对象, 而是从IoC容器获取接口的实现, 这样client不需要知道具体实现是谁
转化成最优化问题
  在六大设计原则的约束条件下, 利用面向对象的三种类关系完成软件功能, 使类图复杂度最小化. (类图指uml图)
@ref https://www.runoob.com/design-pattern/design-pattern-intro.html

服务质量保障
目的是保障服务高可用
高可用分两方面:
  1. 整体上, 通过多机分布式来实现. 关键技术是服务发现、可用性探测
  2. 单机上, 排除机器资源被抢占(资源隔离解决)、代码bug, 影响单实例可用性的因素有下游故障和流量异常(来自上游).
     因此单机质量保障主要是让实例在异常情况时不崩溃, 异常结束后能恢复正常.
     解决方法: 下游故障 -> 熔断机制, 流量异常 -> 限流, 限流后采用兜底逻辑或丢请求来处理.
     一个误区是引入逐级降低质量机制, 比如推荐系统中随请求增多逐步减少召回量, 这种做法完全没有必要.
     因为当业务增长导致实例处理能力不够时, 正确做法是及时优化性能、增加机器资源, 而不是降低服务质量影响用户体验.
     服务处理能力跟不上业务只能是一个短暂时期, 做逐级质量机制属于架构上的过度设计、浪费了人力.
     事实上线上一出现降级报警后就会安排人力跟进性能优化
如何处理流量异常
  流量异常分两种情况: 突发变高 和 持续增长.
  突发变高通过漏桶或令牌限流解决.
  根据"Performance Testing Methodology", 实例随着请求负载(qps)的持续增加, 会经历线性期、瓶颈期、崩溃期.
  自然界的消耗有限资源类型的系统都符合这个模型.
  所以, 解决持续增长问题的核心目标是控制系统稳定在线性期, 且无限接近进入瓶颈期的拐点
  稳定在线性期是为了减少长尾(人们幸福指数高), 无限接近拐点是为了最大化利用机器资源(如cpu, io型应用是网卡)
  控制方法是反馈+限流
  反馈需要注意的是不能过于敏感, 否则系统抖动大
  瓶颈期的判断依据是任务处理队列出现堆积, 若堆积量的导数大于0说明处于崩溃期
流控线程
  http_server模块接收到请求后放入等待队列, 队列满则丢弃请求
  用一个流控线程从等待队列逐个取请求, 根据系统当前状态决定用哪种策略(正常、降级、丢弃)
服务发现和下游熔断参考 Spring Cloud

监控和报警
  分成3个层次
  1. 对监控系统的要求：指标收集、查询低延迟、各种聚合函数、表达式检测、同环比检测
     对业务系统的要求：每个服务做到有问题就有报警，有报警表示有问题的充要条件，不会有漏报和误报
  2. 监控系统往上一层是AIops
     自动异常检测(分段线性回归+加权最小二乘)
     归因分析
  3. 业务系统往上一层是具有容错能力，从而实现高可用
     基础架构的工作：sentinel，Hystrix
     业务架构的工作：降级判断和处理

科学
  用最少的假设，通过逻辑推理演绎获得最大量的经验知识(爱因斯坦)
  逻辑推理演绎是颠扑不破的磐石(笛卡尔)
    其特性和意义在于任何意识和时间在相同的假设下得出的结论完全相同
    这种不变性给人真实感
  需要注意和怀疑的是假设和名词性概念
    质点模型 -> 粒子 -> 波粒二象性 -> 场

# jvm LockSupport 原理
https://kkewwei.github.io/elasticsearch_learning/2018/11/10/LockSupport%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/
~~~cpp
pthread_mutex_t mtx
pthread_cond_t cond

pthread_mutex_init(mtx, NULL)
pthread_cond_init(cond, NULL)

pthread_mutex_lock(mtx)
pthread_mutex_trylock(mtx)
pthread_mutex_unlock(mtx)
~~~

# scala
https://twitter.github.io/scala_school/zh_cn/collections.html

# 代码细节
变量名参考
  opaque 透传参数
  container 持有某些类实例的容器
能用有符号整型则用有符号, 例如数组大小、时间戳, 方便减法