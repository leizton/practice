图形化记忆

关注数据，核心流转数据的修改即是核心流程

工作中需关注重点、难点、亮点
重点：需求痛点, 核心功能, 系统性的问题
难点: 功能实现中遇到的很难解的问题
亮点：创新点、新思路、巧妙的方案方法, 解决了难点问题

可计算问题 图灵机 图灵完备
https://www.zhihu.com/question/20115374

BitFunnel
https://www.jiqizhixin.com/articles/2019-11-20-15

4种容器网络模式
https://blog.csdn.net/qq_38622229/article/details/81840516

日志收集和分析
1. 收集包含指定 keyword 的日志行, 同时过滤掉无需收集的日志
2. agent 做初步解析, 解析结果包括 {app, ip, timestamp, row_id, kv_list}
    row_id 是日志行的唯一标识, 类型是`uint64_t`, 默认用 snowflake 生成
    kv_list 是一个 kv pair 的数组, key value 的类型都是string
3. 通过消息队列发送出去, 如 kafka
4. 用实时流计算框架做OLAP, 如 flink-sql

编程模型
  - 偏于关注数据抽象
    面向对象
  - 偏于关注数据处理
    接口命令式: 面向接口编程
    数据流声明式: java8 stream; 针对某一种数据类型的迭代操作, 数据类型 List<T>
      [flink 数据流编程模型](./adoc/flink/Dataflow_Programming_Model.pdf)
      批数据声明式: 接口参数是list型
    响应式函数编程: 数据流声明式的异步化; 事件(数据)驱动式
数据模型
  - 传统结构体: protobuf
  - 列式内存数据: arrow; 无schema批量数据

分析X业务则必须了解X业务的各类数据和各类逻辑, 数据和业务逻辑无关有形的架构、代码.

推荐系统
- 宏观数据
  - 用户画像, 用户行为历史
  - 文章/视频的正排属性
  - 关联 频道/分类/地域/运营、u2i/i2i、模型向量(dssm) 等的倒排拉链
- 核心逻辑
  - 召回
  - 排序

推荐系统架构
  推荐前台
    业务逻辑单元: Recaller Filter Ranker
    前台引擎功能: 通用推荐流程抽象, 图化recall filter rank的执行; 访问各中台、平台的组件
    前台通用数据: UserInfo Item&ItemList Request/Response/Context Config
  推荐(数据)中台
    用户数据中台  正排和过滤中台   特征中台(用户和样本的在离线特征提取)
    召回服务(内容、i2i、向量召回)  模型服务(深度模型训练和排序算分)
  基础平台
    分布式缓存  分布式持久存储  分布式消息队列  分布式一致性kv数据库
    分布式计算  分布式数据库  OLAP/OLTP  时序数据库
    SRE相关: 分布式服务治理和追踪 监控报警 发布变更系统
    (平台指具有跨业务场景提供通用能力, 其数据模型具有业务无关性)

企业软件系统的技术架构和组织架构
  技术架构
    [网关] [业务前台] [业务数据中台] [基础平台]
    微服务架构包裹网关、前台、中台, SpringCloud可以看成是微服务的代名词
  组织架构
    每个基础平台和业务中台由5或7人的团队负责研发, 这些系统按照云服务产品的要求来设计和实现
    SRE团队运维企业的微服务、监控、变更、资源管理等系统, 负责前台的高可用、高性能、可扩展
    业务研发团队更多的是和产运团队对接, 较少与SRE沟通
    子团队人数应是 2/5/7 三种, 5和7对应出一个leader其余人两两结对
    用软件工程的思想来设计团队, 那么子团队应是高内聚低耦合, 从而使沟通成本最低
    在人力系统中, 沟通是成本最高的类型, 团队间通过接口人沟通
    leader就是接口人, 负责把外部需求准确传递到内部, 使成员明白团队和自身的意义和价值
  架构设计
    技术和组织架构的设计不只是明白系统有哪些要素, 最重要的是设计和维护好要素间的关系, 这需要系统思维
    架构设计工作的最终目的是形成高可靠快速迭代的多业务系统

特征工程的重要性
  往业务里应用深度模型的时间一部分花在特征数据准备上
  好的特征可以在不同业务间互相借鉴

一种特征平台的运行时数据模型的逻辑视图
  一张宽表存放一次请求的所有数据
  表的行数是固定的, 等于输入的item_id数
  表的列分group, 每个group对应一个节点, 例如 source列族 对应请求原始参数 包含列有[item_id, user_profile]
  一个节点也可以创建出多个列族, 节点内通过 group.column 取得具体的列数据
  配置构图: 仅需配置节点的 inputs 和 outputs, 框架自动推导节点依赖关系变成图运行, 所以表的列数在运行前也是确定的
  对于list数据, 如果设置multi-record模式, 则表示这个list是多行; 否则是一行

深度模型
  单目标: ctr
  多目标: 图文点击/视频有效播放(播放时间超过5s相当于点击)、消费时长、、视频完播率
  粗排模型对视频点击有大的指标提升
  粗排模型: 双塔模型 user_embedding向量召回

AI算法发展
  专家系统: 手动配置规则; 规则式逻辑
  机器学习: 面向大量样本的数学最大化
  深度学习: 面向大量样本和大参数集的数学最大化, 和机器学习比能学到更多的人类认知规则
           本质是获得一个超函数, 超指无法写成表达式、参数巨多
           传统的统计学是选择一个合适的模型(函数类型), 然后用样本学习出函数的参数
           模型是对外在事物相互作用的数学上的抽象描述
           更多的时候, 复杂的相互作用不能用简单的函数表达, 因此传统机器学习效果不佳
           当前深度学习最大的问题是需要大量训练样本才能满足大量网络参数, 其次的问题是无法解释导致无法衡量可靠性

uri (identifier) {
  url (locator) https://google.com
  urn (name) isbn:0-486-27557
}

重构的原则
1. 忠于原代码. 尽量不要根据自己的理解去优化代码
2. 逐步实施.
3. 简洁逻辑而非减少代码. 代码量可能会增加, 但目标是逻辑更清晰, 增加功能更容易
4. 选型上合适才是最好的.
@ref https://juejin.cn/post/6844903838193975304

什么时候必须得重构了
  现有的 数据模型(数据结构) 或 实现模型(业务逻辑处理流程) 对新功能新需求很不友好

架构设计的一些思考
过度设计的架构会让业务开发冗余代码，违背易用性的简洁原则
@ref https://juejin.cn/post/6844903639195074574

全链路日志
span的作用: 形成多层树状结构
https://juejin.cn/post/6965178897629462564

设计模式
设计模式本质是围绕类的`继承派生 组合聚合 依赖调用`来做的, 因为类与类之间的关系只有这三种
  派生: 自己作为项目组接口人, 和其他项目组(软件里的模块)交互, 把具体工作(具体实现)派发给后面的同事完成
  继承: 从接口人那里认领需求, 完成具体实现
  组合的形式只有两种: 链式(含集合) 和 映射式, 这也是容器种类、数据结构种类
举例
  行为型
    责任链模式   链式组合+依赖调用+派生
    命令模式     依赖调用+派生; 命令类依赖实现类
    访问者模式   依赖调用+派生; 访问者依赖数据元素
    迭代器模式   聚合+依赖调用; 容器类聚合数据元素, 迭代器依赖数据元素
    观察者模式   依赖调用+派生; Subject类(被观察者)状态变化时调用Observer(观察者)的接口;
                实际中通过异步消息队列、事件总线组件来解耦这个依赖
  结构型
    (以下省略依赖调用)
    代理模式     组合; 代理类组合一个实现类; client依赖代理类; 代理类起到保护实现类的作用
    装饰器模式   组合+派生; 装饰器组合一个实现类; 装饰器派生出子类扩展原实现的功能; client依赖装饰器
                装饰器和代理的区别在于多了一个派生, 使得他们的功能不同
    外观模式     集合式组合; 外观类组合多个不同实现类, 对外提供不同接口对应不同实现; client依赖外观类
    中介者模式   依赖调用; 类之间不直接交互, 而是通过中介者, 从而将网状依赖关系简化成星形
    桥接模式     依赖调用; client依赖原接口, 原接口依赖桥接接口;
                原本是桥接接口继承原接口, 自己再扩展新接口, 让具体类实现;
                因此会出现多层继承, 为了简化把桥接继承原接口的关系变成依赖关系
  创建型
    依赖构造方法
    抽象工厂就是在工厂模式上增加了派生
    对象的创建和管理最佳实践是用Spring的IoC思想(控制反转-依赖注入)
    控制指管理对象的生命周期, 甚至包括创建对象;
    反转指client不自己new实现对象, 而是从IoC容器获取接口的实现, 这样client不需要知道具体实现是谁
转化成最优化问题
  在六大设计原则的约束条件下, 利用面向对象的三种类关系完成软件功能, 使类图复杂度最小化. (类图指uml图)
@ref https://www.runoob.com/design-pattern/design-pattern-intro.html

服务质量保障
目的是保障服务高可用
高可用分两方面:
  1. 整体上, 通过多机分布式来实现. 关键技术是服务发现、可用性探测
  2. 单机上, 排除机器资源被抢占(资源隔离解决)、代码bug, 影响单实例可用性的因素有下游故障和流量异常(来自上游).
     因此单机质量保障主要是让实例在异常情况时不崩溃, 异常结束后能恢复正常.
     解决方法: 下游故障 -> 熔断机制, 流量异常 -> 限流, 限流后采用兜底逻辑或丢请求来处理.
     一个误区是引入逐级降低质量机制, 比如推荐系统中随请求增多逐步减少召回量, 这种做法完全没有必要.
     因为当业务增长导致实例处理能力不够时, 正确做法是及时优化性能、增加机器资源, 而不是降低服务质量影响用户体验.
     服务处理能力跟不上业务只能是一个短暂时期, 做逐级质量机制甚至于调参属于架构上的过度设计、浪费了人力.
如何处理流量异常
  流量异常分两种情况: 突发变高 和 持续增长.
  突发变高通过漏桶或令牌限流解决.
  根据"Performance Testing Methodology", 实例随着请求负载(qps)的持续增加, 会经历线性期、瓶颈期、崩溃期.
  自然界的消耗有限资源类型的系统都符合这个模型.
  所以, 解决持续增长问题的核心目标是控制系统稳定在线性期, 且无限接近进入瓶颈期的拐点
  稳定在线性期是为了减少长尾(人们幸福指数高), 无限接近拐点是为了最大化利用机器资源(如cpu, io型应用是网卡)
  控制方法是反馈+限流
  反馈需要注意的是不能过于敏感, 否则系统抖动大
  瓶颈期的判断依据是任务处理队列出现堆积, 若堆积量的导数大于0说明处于崩溃期
流控线程
  http_server模块接收到请求后放入等待队列, 队列满则丢弃请求
  用一个流控线程从等待队列逐个取请求, 根据系统当前状态决定用哪种策略(正常、降级、丢弃)
服务发现和下游熔断参考 Spring Cloud

科学
  用最少的假设，通过逻辑推理演绎获得最大量的经验知识(爱因斯坦)
  逻辑推理演绎是颠扑不破的磐石(笛卡尔)
    其特性和意义在于任何意识和时间在相同的假设下得出的结论完全相同
    这种不变性给人真实感
  需要注意和怀疑的是假设和名词性概念
    质点模型 -> 粒子 -> 波粒二象性 -> 场

# jvm LockSupport 原理
https://kkewwei.github.io/elasticsearch_learning/2018/11/10/LockSupport%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/
~~~cpp
pthread_mutex_t mtx
pthread_cond_t cond

pthread_mutex_init(mtx, NULL)
pthread_cond_init(cond, NULL)

pthread_mutex_lock(mtx)
pthread_mutex_trylock(mtx)
pthread_mutex_unlock(mtx)
~~~

# scala
https://twitter.github.io/scala_school/zh_cn/collections.html

# 代码细节
变量名参考
  opaque 透传参数
能用有符号整型则用有符号, 例如数组大小、时间戳, 方便减法

# plot
Highcharts

# sign
㈠㈡㈢㈣㈤㈥㈦㈧㈨㈩
①②③④⑤⑥⑦⑧⑨⑩
⑴⑵⑶⑷⑸⑹⑺⑻⑼⑽
⒈⒉⒊⒋⒌⒍⒎⒏⒐⒑

☆ ★ ☉ ⊕ □ ■ ○ ● ✓ × 

↖ ↑ ↗ → ↔ ← ↙ ↓ ↘

＋ －  ×  ÷  ·  ±
㏒ ㏑  ∑  ∏
∈  ∉  ≌  ∅  Φ
∂  ┆ ┃

α β θ γ ω δ η ζ φ λ μ σ π

上标  ⁰ ¹ ² ³ ⁴ ⁵ ⁶ ⁷ ⁸ ⁹ ⁺ ⁻ ⁼ ⁽ ⁾ º ˙ ᶺ ᵃ ᵇ ᶜ ᵈ ᵉ ᵍ ʰ ⁱ ʲ ᵏ ˡ ᵐ ⁿ ᵒ ᵖ ʳ ˢ ᵗ ᵘ ᵛ ʷ ˣ ʸ ᙆ
下标  ₀ ₁ ₂ ₃ ₄ ₅ ₆ ₇ ₈ ₉ ₊ ₋ ₌ ₍ ₎ ₐ ₑ ₕ ᵢ ₖ ₗ ₘ ₙ ₒ ₚ ᵣ ₛ ₜ ᵤ ᵥ ₓ
