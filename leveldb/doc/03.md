# sst0Table
### BlockHandle
- offset  long
- size    long

### BlockBuilder
- buffer       string       Block的物理内容
- add_counter  int          每个一定数量的entry后重置key-share
- restarts     vector<int>  重置key-share时buffer的偏移
> add(key, value)
    一个entry: shared_key_size | unshared_key_size | value_size | delta_key | value
> block末尾写入restarts

### TableBuilder
- data_block    BlockBuilder        数据块, 包含众多entry和restart
- index_block   BlockBuilder        索引块, 存放每个data-block在文件中的偏移和大小
- filter_block  FilterBlockBuilder  布隆过滤器
> data-block都写完后, 再写入index-block


# Compaction
- level          int
- inputs         vector<FileMetaData*>[2]
- input_version  Version*


# DBImpl::backgroundCompaction
    把memTable(imm_)写入sst0Table
        1 把imm_写到sst0文件, 因为imm_是有序的, 所以单个sst0文件是key有序的
            iter = new MemTableIterator(imm_.table_)
            file = new WritableFile("${dbname}/${meta.number}.ldb")
            通过TableBuilder, 遍历把iter写入file, 文件结构@ref sst_1.png
            FileMetaData meta = { number = versions_.next_file_number++, smallest = iter的第一个key, largest = iter的最后一个key }
        2 更新version
            // 确定应该把meta放到哪一层上
            int level = versions_.current_.PickLevelForMemTableOutput(meta)
                // isOverlapInLevel(level, meta): 判断meta的[smallest,largest]和第level层的某个sst文件的key范围是否有交集
                // totalSizeOfOverlapInLevel(level, meta): 统计第level层中与meta有交集的所有sst文件的size的和
                if isOverlapInLevel(0, meta) => 0
                for level = 0:kMaxMemCompactLevel(2)  // level取0或1
                    if isOverlapInLevel(level+1, meta) => level
                    if totalSizeOfOverlapInLevel(level+2, meta) > 10*options.max_file_size => level
                => kMaxMemCompactLevel-1
            // 应用新的version
            versions_.logAndApply(VersionEdit{ new_files={<level,meta>}, log_number=impl_.logfile_number }
                compact_pointer_存入edit
                edit写入manifest文件
                创建新的version, 由Builder把edit和current_合并到新的version上
                append新version, current_ = version
                version.findBestCompactLevelByFileNumOrSize()
    Compaction* cpt = versions_.PickCompaction()
        cpt = new Compaction()
        if current_.compact_score_ >= 1  // size_compact, 选择findBestCompactLevelByFileNumOrSize的level
            l = current_.compact_level_
            cpt.input_[0].push_back(current_第l层中largest大于compact_pointer_[l]的文件)
        elif current_.file_to_compact_ != NULL  // seek_compact
            l = current_.file_to_compact_level_
            cpt.input_[0].push_back(current_.file_to_compact)
        else
            return NULL
        if l == 0 // 第0层扩展
            do
                smallest, largest = cpt.input_[0]的最小、最大key
                cpt.input_[0].clear()
                cpt.input_[0].push_back(current_第0层上和[smallest, largest]有key重叠的sst0文件)
            while (cpt.input_[0]有改变)  // 循环expand
        cpt = { level_=l, input_version_=current_ }