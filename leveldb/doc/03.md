# sst0Table
### BlockHandle
- offset  long
- size    long

### BlockBuilder
- buffer       string       Block的物理内容
- add_counter  int          每个一定数量的entry后重置key-share
- restarts     vector<int>  重置key-share时buffer的偏移
> add(key, value)
    一个entry: shared_key_size | unshared_key_size | value_size | delta_key | value
> block末尾写入restarts

### TableBuilder
- data_block    BlockBuilder        数据块, 包含众多entry和restart
- index_block   BlockBuilder        索引块, 存放每个data-block在文件中的偏移和大小
- filter_block  FilterBlockBuilder  布隆过滤器
> data-block都写完后, 再写入index-block


# DBImpl::backgroundCompaction
    把memTable(imm_)写入sst0Table
        1 写sst0文件
            iter = new MemTableIterator(imm_.table_)
            file = new WritableFile("${dbname}/${meta.number}.ldb")
            通过TableBuilder, 遍历把iter写入file, 文件结构@ref sst_1.png
            FileMetaData meta = { number = versions_.next_file_number++,
                smallest = iter的第一个key, largest = iter的最后一个key }
        2 更新version
            int level = versions_.current_.PickLevelForMemTableOutput()
                如果meta的key取值范围和第0层的某个sst文件有交集, 即OverlapInLevel(0, meta)==true, 返回0