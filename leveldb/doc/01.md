# FileMetaData
- number     long         文件编号
- file_size  long
- smallest   InternalKey
- largest    InternalKey
> compare()  先比较smallest，再是number

# Version
- files          vector<FileMetaData*>[kNumLevels]  包含所有层的文件元数据
- compact_level  int
- compact_score  double

# VersionSet
- dummy_versions    Version  空头节点
- current           Version
- next_file_number  long

# VersionEdit
- log_number        long
- prev_log_number   long
- last_sequence     long
- next_file_number  long
- compact_pointers  vector<pair<int, InternalKey>>   pair.first都是level
- deleted_files     set<pair<int, long>>             second是FileMetaData::number
- new_files         vector<pair<int, FileMetaData>>

# WritableFile
- 封装文件名和文件句柄, 提供写文件的方法

# Writer
- 组合一个WritableFile对象，提供addRecord(slice)方法
- 文件在物理上有众多大小固定(kBlockSize=32768)的block组成
- 逻辑单元是record, record被拆成一或多个[type|data]
- type表示后面的data是完整的一个record(kFullType), 或record的第一个data(kFirstType), kLastType, kMiddleType

# DB::open
    impl = new DBImpl
        versions_ = new VersionSet(dbname, table_cache_)
            dummy_versions_ = new Version(this)  // 双链表的空头节点
            current_ = new Version(this)
            appendVersion(current_)  // current_加到双链表尾部(header前面)
    impl.recover
        create dbname目录, dbname/LOCK文件
        create dbname/MANIFEST-000001描述文件, 写入一个空的VersionEdit
        把"MANIFEST-000001"(当前描述文件名)写入dbname/CURRENT文件
        versions_.recover
            遍历CURRENT文件中指定的manifest文件的所有VersionEdit
            把所有的VersionEdit累积起来得到一个Version v
            appendVersion(v)
            manifest_file_number_ = int("000001")
    impl.init
        新的logfile文件编号: logfile_number_ = versions_.next_file_number++
        创建logfile: logfile_ = new WritableFile("${dbname}/${logfile_number_}.log")
                    log_ = new Writer(logfile)
        mem_ = new MemTable
    impl.maybeScheduleCompaction

# DBImpl::Write

# DBImpl::maybeScheduleCompaction